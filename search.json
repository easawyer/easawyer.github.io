[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home Page",
    "section": "",
    "text": "This is a Quarto website. It will gradually be updated throughout this semester with more homework and (hopefully) better graphic design.\nWebsite last updated 10/6/2025."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I’m Elise, and this is the website I have created for my Data Visualization class. I am a graduate student in Geospatial Information Sciences at the University of Texas at Dallas. I am also an intern with the City of Plano. I help run UTD’s board game club and my other hobbies include solving word puzzles, playing difficult video games, and reading!\n(page last updated: 9/22/2025)"
  },
  {
    "objectID": "Homework 1.html",
    "href": "Homework 1.html",
    "title": "Homework 1",
    "section": "",
    "text": "1)\nFrancis J. Anascombe’s “Graphs in statistical analysis” demonstrates the flaws in assuming that specific aspects of statistical analysis give a clear indication of how data is distributed. He uses four sets of eleven points that, while different in composition, share incredibly similar means, regression coefficients + equations, error estimations, etc. The first “example” is a more standard set of scattered points, the second has points which resemble a quadratic relationship, and the third and fourth figures each involve one “outlier” point. This paper emphasizes the importance of examining data graphically to better account for situations such as these– seeing the differences in these four sets of points already helps prevent people from assuming they are identical. Additionally, the paper discusses how in situations such as those found in examples 3 and 4 (with one point greatly influencing a result), acknowledging that point’s contribution and how data would change with its absence could be helpful. A noteworthy aspect of this paper to me is how it is over 50 years old; Anascombe references how creating and examining data graphically is a process requiring “trouble, cunning, and a fighting spirit” and hopes that this will change. His hope has since been realized, so the challenge of dealing with sets of data such as these is less related to dedication to computer programming, and more related to understanding when simply reporting means and equations wouldn’t be enough.\n2) See above image.\n3) The data visualization I will critique is by Darren McCleary, which I found in a New York Times article related to crossword construction (one of my hobbies is solving crosswords, and I’ve tried my hand in the past at making them). It is a set of heat maps explaining how likely a square in a crossword grid is to be a black square (as opposed to a square where you can place a letter). \nThe color scheme works for this being a heat map, though I do think that it is difficult to distinguish between the pale yellow and white parts of the charts. One idea of how the difficult-to-see color scheme could be fixed is the use of a diverging color palette. For instance, a square could be more red if it is more likely to be a filled square than not, and more blue if it is more likely to be an empty square. However, this solution presents a new problem. As this graphic is about the likelihood of squares being filled in with a dark color, having both the “especially likely to be filled in” squares as well as the “especially likely to be empty” squares be represented in dark colors would be problematic.\nAdditionally, these heat maps do not give any legend about the differences between the darker and lighter squares (only that darker spaces are more likely to have black squares). My issue is not that the graphic avoided using numbers to explain this (as its audience is just people who are reading the crossword construction advice article), but that this graphic does use numbers for the x and y axis of the graphs. I don’t understand why they chose to have the highest square on the y axis be represented with “0”. While crosswords do typically start their lists of clues with ones for the words in the top left, it makes this chart more confusing to look at, although this could have been avoided by labeling the x axis at the top rather than at the bottom of each chart.\nOne detail that would have been interesting is to label which squares are the most frequently-used for black spaces, or least frequently used, via some sort of indication on the chart.\nhttp://nytimes.com/2018/05/11/crosswords/how-to-make-crossword-puzzle-grid.html"
  },
  {
    "objectID": "Homework 2.html",
    "href": "Homework 2.html",
    "title": "Homework 2",
    "section": "",
    "text": "(Page last updated 9/30/2025)"
  },
  {
    "objectID": "Homework 3.html",
    "href": "Homework 3.html",
    "title": "Homework 3",
    "section": "",
    "text": "Rerun murrell01.R. Choose one of the six charts and explain how it is configured by adding documentation to the codes.\n\n\n# Boxplot\n#par() sets up graphical parameters. Currently the only parameter set here is \"mar\", which sets up the bottom, left, top, and right margins around the plot. \npar(mar=c(3, 4.1, 2, 0))\n#boxplot(), as the name suggests, produces boxplots. In order, this is what the code does:\n  #creates a formula (len~dose) to split the data into groups. Y value is tooth   length, and data is separated by dose amount.\n  #gets data from the ToothGrowth dataframe (related to tooth growth in guinea pigs)\n  #\"boxwex\" can widen or narrow the boxplots. In this case it narrows them.\n  #\"at\" chooses which locations the boxes are drawn at.\n  #as there are 2 supplement types for tooth growth in this data frame, the code specifies that these 3 plots will be for the \"VC\" value of supplement type (acsorbic acid). The color of these plots will be white.\n  #does not label the x axis, but does label the y axis. Specifies that y axis will go from 0-35.\nboxplot(len ~ dose, data = ToothGrowth,\n        boxwex = 0.25, at = 1:3 - 0.2,\n        subset= supp == \"VC\", col=\"white\",\n        xlab=\"\",\n        ylab=\"tooth length\", ylim=c(0,35))\n#Then, the code adds text to the bottom side of the graphic, on the 2.5 margin line with 0.8 as the character expansion factor. The 'character expansion factor' controls text size relative to the rest of the graphic.\nmtext(\"Vitamin C dose (mg)\", side=1, line=2.5, cex=0.8)\n#The code then adds three more boxplots to the graphic. New things being done in this code include:\n  #setting \"add\" to TRUE so that way the boxplots are moved to the chart\n  #unlike the previous boxplot code, \"at\" has \"+0.2\" rather than \"-0.2\". This means that the boxes related to orange juice (as is specified later that these are) will all be slightly to the right of the boxes related to ascorbic acid.\nboxplot(len ~ dose, data = ToothGrowth, add = TRUE,\n        boxwex = 0.25, at = 1:3 + 0.2,\n        subset= supp == \"OJ\")\n#legend() adds legends to plots. In this case the legend is located at the coordinates of (1.5,9). The code then adds the legend expression (labelling the two types of plots), fills the legend with appropriate colors, and specifies that no box will be around the legend. The default value for \"bty\" is \"o\", which means the legend will have a box around it.\nlegend(1.5, 9, c(\"Ascorbic acid\", \"Orange juice\"), \n       fill = c(\"white\", \"gray\"), \n       bty=\"n\")\n\n\n\n\n\n\n\n\n\nRerun anscombe01.R. Compare the regression models, compare different ways to create the plots.\n\nAs seen in the (slightly altered) version of the anscombe01 code below, the “simple version” of creating the plots entails creating a separate scatterplot for each of the models, and then adding a straight line through each plot using their coefficients.\nThe “fancy version” involves loops which assign and use “names”; it additionally utilizes the par() function to make a 2x2 display of plots and set up the margins both between and around the plots. The final loop with the plot function itself sets up the plotting character (pch) for the points, the fill color of the points (bg) along with their outline color (col), and the size of the points relative to the other components of the plot (cex). The addition of lines to each plot is similar to the “simple version”, but this time these plots are made in blue.\n\ndata(anscombe)  # Load Anscombe's data\n\n## Simple version\nplot(anscombe$x1,anscombe$y1)\n#summary(anscombe)\n\n# Create four model objects\n#(commenting out the summaries)\nlm1 &lt;- lm(y1 ~ x1, data=anscombe)\n#summary(lm1)\nlm2 &lt;- lm(y2 ~ x2, data=anscombe)\n#summary(lm2)\nlm3 &lt;- lm(y3 ~ x3, data=anscombe)\n#summary(lm3)\nlm4 &lt;- lm(y4 ~ x4, data=anscombe)\n#summary(lm4)\nplot(anscombe$x1,anscombe$y1)\nabline(coefficients(lm1))\n\n\n\n\n\n\n\nplot(anscombe$x2,anscombe$y2)\nabline(coefficients(lm2))\n\n\n\n\n\n\n\nplot(anscombe$x3,anscombe$y3)\nabline(coefficients(lm3))\n\n\n\n\n\n\n\nplot(anscombe$x4,anscombe$y4)\nabline(coefficients(lm4))\n\n\n\n\n\n\n\n## Fancy version (per help file)\n\nff &lt;- y ~ x\nmods &lt;- setNames(as.list(1:4), paste0(\"lm\", 1:4))\n\n# Plot using for loop\nfor(i in 1:4) {\n  ff[2:3] &lt;- lapply(paste0(c(\"y\",\"x\"), i), as.name)\n  ## or   ff[[2]] &lt;- as.name(paste0(\"y\", i))\n  ##      ff[[3]] &lt;- as.name(paste0(\"x\", i))\n  mods[[i]] &lt;- lmi &lt;- lm(ff, data = anscombe)\n  print(anova(lmi))\n}\n\nAnalysis of Variance Table\n\nResponse: y1\n          Df Sum Sq Mean Sq F value  Pr(&gt;F)   \nx1         1 27.510 27.5100   17.99 0.00217 **\nResiduals  9 13.763  1.5292                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nAnalysis of Variance Table\n\nResponse: y2\n          Df Sum Sq Mean Sq F value   Pr(&gt;F)   \nx2         1 27.500 27.5000  17.966 0.002179 **\nResiduals  9 13.776  1.5307                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nAnalysis of Variance Table\n\nResponse: y3\n          Df Sum Sq Mean Sq F value   Pr(&gt;F)   \nx3         1 27.470 27.4700  17.972 0.002176 **\nResiduals  9 13.756  1.5285                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\nAnalysis of Variance Table\n\nResponse: y4\n          Df Sum Sq Mean Sq F value   Pr(&gt;F)   \nx4         1 27.490 27.4900  18.003 0.002165 **\nResiduals  9 13.742  1.5269                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nsapply(mods, coef)  # Note the use of this function\n\n                  lm1      lm2       lm3       lm4\n(Intercept) 3.0000909 3.000909 3.0024545 3.0017273\nx1          0.5000909 0.500000 0.4997273 0.4999091\n\nlapply(mods, function(fm) coef(summary(fm)))\n\n$lm1\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0000909  1.1247468 2.667348 0.025734051\nx1          0.5000909  0.1179055 4.241455 0.002169629\n\n$lm2\n            Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.000909  1.1253024 2.666758 0.025758941\nx2          0.500000  0.1179637 4.238590 0.002178816\n\n$lm3\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0024545  1.1244812 2.670080 0.025619109\nx3          0.4997273  0.1178777 4.239372 0.002176305\n\n$lm4\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0017273  1.1239211 2.670763 0.025590425\nx4          0.4999091  0.1178189 4.243028 0.002164602\n\n# Preparing for the plots\nop = par(mfrow = c(2, 2), mar = 0.1+c(4,4,1,1), oma =  c(0, 0, 2, 0))\n\n# Plot charts using for loop\nfor(i in 1:4) {\n  ff[2:3] &lt;- lapply(paste0(c(\"y\",\"x\"), i), as.name)\n  plot(ff, data = anscombe, col = \"red\", pch = 21, bg = \"orange\", cex = 1.2,\n       xlim = c(3, 19), ylim = c(3, 13))\n  abline(mods[[i]], col = \"blue\")\n}\nmtext(\"Anscombe's 4 Regression data sets\", outer = TRUE, cex = 1.5)\n\n\n\n\n\n\n\npar(op)\n\n\nFinetune the charts without other packages.\n\n(Serif font, non-default colors, own plotting character)\n\ndata(anscombe)\n\nlm1 &lt;- lm(y1 ~ x1, data=anscombe)\nlm2 &lt;- lm(y2 ~ x2, data=anscombe)\nlm3 &lt;- lm(y3 ~ x3, data=anscombe)\nlm4 &lt;- lm(y4 ~ x4, data=anscombe)\n\nff &lt;- y ~ x\nmods &lt;- setNames(as.list(1:4), paste0(\"lm\", 1:4))\n\nfor(i in 1:4) {\n  ff[2:3] &lt;- lapply(paste0(c(\"y\",\"x\"), i), as.name)\n  ## or   ff[[2]] &lt;- as.name(paste0(\"y\", i))\n  ##      ff[[3]] &lt;- as.name(paste0(\"x\", i))\n  mods[[i]] &lt;- lmi &lt;- lm(ff, data = anscombe)\n}\n\nsapply(mods, coef)\n\n                  lm1      lm2       lm3       lm4\n(Intercept) 3.0000909 3.000909 3.0024545 3.0017273\nx1          0.5000909 0.500000 0.4997273 0.4999091\n\nlapply(mods, function(fm) coef(summary(fm)))\n\n$lm1\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0000909  1.1247468 2.667348 0.025734051\nx1          0.5000909  0.1179055 4.241455 0.002169629\n\n$lm2\n            Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.000909  1.1253024 2.666758 0.025758941\nx2          0.500000  0.1179637 4.238590 0.002178816\n\n$lm3\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0024545  1.1244812 2.670080 0.025619109\nx3          0.4997273  0.1178777 4.239372 0.002176305\n\n$lm4\n             Estimate Std. Error  t value    Pr(&gt;|t|)\n(Intercept) 3.0017273  1.1239211 2.670763 0.025590425\nx4          0.4999091  0.1178189 4.243028 0.002164602\n\n#font set to serif here along with other color changes\nop = par(mfrow = c(2, 2), mar = 0.1+c(4,4,1,1), oma =  c(0, 0, 2, 0),family=\"serif\",col.axis=\"royalblue4\",col.lab=\"royalblue2\",col.axis=\"royalblue3\",bg=\"snow1\")\n#added color list. decided to not do a filled shape but included \"fillc\" anyways from when i initially planned to\n#fillc &lt;- c(\"firebrick2\",\"seagreen2\",\"gold\",\"orchid1\")\noutc &lt;- c(\"firebrick4\",\"seagreen\",\"gold4\",\"darkorchid\")\nfor(i in 1:4) {\n  ff[2:3] &lt;- lapply(paste0(c(\"y\",\"x\"), i), as.name)\n  plot(ff, data = anscombe, col = outc[i], pch = \"*\", cex = 1.2,\n       xlim = c(3, 19), ylim = c(3, 13))\n  abline(mods[[i]], col = \"blue\")\n}\nmtext(\"Anscombe's 4 Regression data sets\", outer = TRUE, cex = 1.5)\n\n\n\n\n\n\n\npar(op)\n\n\nWith ggplot 2 (tidyverse package)?\n\n\nlibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.4.3\n\n\nWarning: package 'ggplot2' was built under R version 4.4.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata(anscombe)\noutc &lt;- c(\"firebrick4\",\"seagreen\",\"gold4\",\"darkorchid\")\nfor(k in 1:4) {\n  print(\"test\")\n  q &lt;- ggplot(data=anscombe, mapping=aes(x=.data[[paste0(\"x\", k)]],y=.data[[paste0(\"y\", k)]]))+geom_point(color=outc[k],shape=8,size=4)+geom_smooth(formula=y~x,method=\"lm\",se=FALSE)+theme(panel.background=element_rect(fill=\"snow1\"),text=element_text(family=\"serif\"))\n  print(q)\n}\n\n[1] \"test\"\n\n\n\n\n\n\n\n\n\n[1] \"test\"\n\n\n\n\n\n\n\n\n\n[1] \"test\"\n\n\n\n\n\n\n\n\n\n[1] \"test\"\n\n\n\n\n\n\n\n\n# for(k in 1:4) {\n#   print(\"test\")\n#   quartet[[k]] &lt;- ggplot(data=anscombe, mapping=aes(x=.data[[paste0(\"x\", k)]],y=.data[[paste0(\"y\", k)]]))+geom_point(color=outc[k],shape=8,size=4)+geom_smooth(formula=y~x,method=\"lm\",se=FALSE)+theme(panel.background=element_rect(fill=\"snow1\"),text=element_text(family=\"serif\"))\n# }\n# print(quartet)\n\n(Page last updated 10/6/2025)"
  }
]